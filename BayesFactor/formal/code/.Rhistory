Data<- Data[,-1]
Data <- t(as.matrix(Data))
X <- Data[,-1]
y <- Data[,1]
Xa <- X[,1:10]
Xb <- X[,-(1:10)]
n <- nrow(Xa)
q <- ncol(Xa)
p <- ncol(Xb)
myVariable <- Variable(p)
obj <- sum(myVariable^2)
myProblem <- Problem(Minimize(obj))
myEPWeight <- solve(myProblem)
myEPWeight
?Problem
?eigen
# EigenPrism: inference for high dimensional signal-to-noise ratios
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)
eigenXbXbT
colMeans(Xb)
# EigenPrism: inference for high dimensional signal-to-noise ratios
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)
myVariable <- Variable(p)
obj <- sum(myVariable^2)
myConstr <- list(sum(myVariable)==0,sum(myVariable*eigenXbXbT)==1)
myProblem <- Problem(Minimize(obj))
myEPWeight <- solve(myProblem)
sum(myVariable)==0
?list
list(a,b)
list(1,2)
sum(myVariable*eigenXbXbT)==1
?Variable
?mul_elemwise
# EigenPrism: inference for high dimensional signal-to-noise ratios
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)
myVariable <- Variable(p)
obj <- sum(myVariable^2)
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj))
myEPWeight <- solve(myProblem)
sum(eigenXbXbT * myVariable)
mul_elemwise(eigenXbXbT, myVariable)
eigenXbXbT
# EigenPrism: inference for high dimensional signal-to-noise ratios
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)$values
myVariable <- Variable(p)
obj <- sum(myVariable^2)
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj))
myEPWeight <- solve(myProblem)
sum(eigenXbXbT * myVariable)
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)$values
myVariable <- Variable(n)
obj <- sum(myVariable^2)
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj))
myEPWeight <- solve(myProblem)
myEPWeight
?solve
myEPWeight$solver
myEPWeight$value
myEPWeight$value
# EigenPrism: inference for high dimensional signal-to-noise ratios
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)$values
myVariable <- Variable(n)
obj <- sum(myVariable^2)
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj),myConstr)
myEPWeight <- solve(myProblem)
myEPWeight$value
myEPWeight$getValue
myEPWeight$status
eigenXbXbT
vignette(package="CVXR")
vignette("cvxr_intro")
myEPWeight$getValue
myEPWeight$getValue(myVariable)
sum(myEPWeight$getValue(myVariable) * eigenXbXBT)
sum(myEPWeight$getValue(myVariable) * eigenXbXbT)
sum(myEPWeight$getValue(myVariable) )
eigenXbXbT
sum(myEPWeight$getValue(myVariable)^2)
txz <- myEPWeight$getValue(myVariable)
txz[1]/txz[2]
eigenXbXbT-mena(eigenXbXbT)
eigenXbXbT-mean(eigenXbXbT)
jjj[1]/jjj[2]
jjj <- eigenXbXbT-mean(eigenXbXbT)
jjj[1]/jjj[2]
# EigenPrism: inference for high dimensional signal-to-noise ratios
eigenXbXbT <- eigen(Xb%*%t(Xb),symmetric = TRUE, only.values = TRUE)$values
myVariable <- Variable(n)
obj <- max(sum(myVariable^2),sum(myVariable^2 * eigenXbXbT^2))
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj),myConstr)
myEPWeight <- solve(myProblem)
txz <- myEPWeight$getValue(myVariable)
txz
eigenXbXbT^(-1)-mean(eigenXbXbT^(-1))
# EigenPrism: inference for high dimensional signal-to-noise ratios
ohoh <- eigen(Xb%*%t(Xb),symmetric = TRUE)
eigenXbXbT <- ohoh$values
myUb <- eigenXbXbT$vectors
myUb <- ohoh$vectors
?eigen
myUb%*%diag(eigenXbXbT)%*%t(myUb)
Xb%*%t(Xb)
(Xb%*%t(Xb))[1:10,1:10]
(Xb%*%t(Xb))[1:2,1:2]
(myUb%*%diag(eigenXbXbT)%*%t(myUb))[1:2,1:2]
y <- rep(1,n)
# EigenPrism: inference for high dimensional signal-to-noise ratios
myZ <- t(myUb) %*% y
myZ
str(myZ)
str(as.numeric(myZ))
?solve
qnorm(1-alpha)
alpha <- 0.05
qnorm(1-alpha)
ohT/ ( sqrt(2*myValP1) * sum(y^2)/n ) > qnorm(1-alpha)
ohT <- sum(myEPWeight * myZ^2 )
myEPWeight
library(xtable)
set.seed(1)
RepTime <- 500
M <- 1000
alpha <- 0.05
n <- 100
q <- 10
p <- 1000
XGen <- "real"
n <- 100
epsilonDis <- "t"
betabGen <- "dense"
source("./code.R")
biaoge1 <-as.matrix(ohResult)
betabGen <- "sparse"
source("./code.R")
biaoge2 <- as.matrix(ohResult)
epsilonDis <- "chi"
betabGen <- "dense"
source("./code.R")
biaoge3 <-as.matrix(ohResult)
betabGen <- "sparse"
source("./code.R")
biaoge4 <- as.matrix(ohResult)
finalBiaoge <- cbind(biaoge1,biaoge2[,-1],biaoge3[,-1],biaoge4[,-1])
print(xtable(finalBiaoge,auto=TRUE),include.rownames = FALSE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
eigenXbXbT
myEPWeight
ohT/ ( sqrt(2*myValP1) * sum(y^2)/n )
zzz <-NULL
for(i in 1:RepTime){
# betaGen
if(betabGen == "dense") {
betabO <- runif(p,-1,1)
}
if(betabGen == "sparse") {
betabO <- runif(p,-1,1)
betabO[sample(p,p/20*19)] <- 0
}
meanSig <- Xb%*% betabO
# Generate y
tmpSNR <- sqrt((n-q)*varGamma)*sum(betabO^2)/p
#betab <- betabO/sqrt(tmpSNR)*sqrt(SNR)
if(epsilonDis == "t")
innov <- rt(n,8)
if(epsilonDis == "chi")
innov <- (rchisq(n,4)-4)/sqrt(8)
y <- innov + meanSig/sqrt(tmpSNR)*sqrt(SNR)
# EigenPrism: inference for high dimensional signal-to-noise ratios
myZ <- as.numeric( t(myUb) %*% y )
ohT <- sum(myEPWeight * myZ^2 )
epResult[i] <- ( ohT/ ( sqrt(2*myValP1) * sum(y^2)/n ) > qnorm(1-alpha) )
zzz[i] <- ohT/ ( sqrt(2*myValP1) * sum(y^2)/n )
### GT statistics
Y <- y
S <- sum(Y * (XX %*% Y)) / sum((t(tildeUa) %*% Y)^2)
lams <- lam
lams[1:(n-q)] <- lams[1:(n-q)] - S
p.value <- .getP(lams)
gtResult[i] <- (p.value <alpha)
# proposed statistic
theNumerator <- as.numeric(
t(y) %*% myBase %*% y
)
theDenominator <- sum(
(t(tildeUa) %*% y)^2
)
proposedStat <- theNumerator / theDenominator
# estimation of tau square
tildeEpsilon <- tildePa %*% y
tauSquare <-
(
(n-q)^2 * sum(tildeEpsilon^4)/sum(tildeEpsilon^2)^2-
3*sum(diag(tildePa)^2)
)/
(
sum(tildePa^4)
)+
2
if(tauSquare < 0) tauSquare <- 0
tau <- sqrt(tauSquare)
# reference distribution
myRef <- tau * ref1 + ref2
if(mean(myRef > ((n-q)*proposedStat)-sum(diag(myBase))) <alpha){
myResultOld[i] <- 1
}
else{
myResultOld[i] <- 0
}
# myRefStep1 <- tau * (refBase1 - x0 * refPlus1) + refBase2 - x0 * refPlus2
# x1 <- quantile(myRefStep1,1-alpha)/(n-q) + x0
#
# myRefStep2 <- tau * (refBase1 - x1 * refPlus1) + refBase2 - x1 * refPlus2
# x2 <- quantile(myRefStep2,1-alpha)/(n-q) + x0
# if(proposedStat > x2){
#     myResult[i] <- 1
# }
# else{
#     myResult[i] <- 0
# }
#
#
# if(proposedStat > x1){
#     myResultTmp[i] <- 1
# }
# else{
#     myResultTmp[i] <- 0
# }
}
mean(zzz)
var(zzz)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
eigenXbXbT-mean(eigenXbXbT)
myEPWeight
myValP1
max(sum(myEPWeight^2),sum(myEPWeight^2 * eigenXbXbT^2))
?solve
ohMyTmp$status
solve(myProblem,verbouse=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
for(i in 1:RepTime){
# betaGen
if(betabGen == "dense") {
betabO <- runif(p,-1,1)
}
if(betabGen == "sparse") {
betabO <- runif(p,-1,1)
betabO[sample(p,p/20*19)] <- 0
}
meanSig <- Xb%*% betabO
# Generate y
tmpSNR <- sqrt((n-q)*varGamma)*sum(betabO^2)/p
#betab <- betabO/sqrt(tmpSNR)*sqrt(SNR)
if(epsilonDis == "t")
innov <- rt(n,8)
if(epsilonDis == "chi")
innov <- (rchisq(n,4)-4)/sqrt(8)
y <- innov + meanSig/sqrt(tmpSNR)*sqrt(SNR)
# EigenPrism: inference for high dimensional signal-to-noise ratios
myZ <- as.numeric( t(myUb) %*% y )
ohT <- sum(myEPWeight * myZ^2 )
epResult[i] <- ( ohT/ ( sqrt(2*myValP1) * sum(y^2)/n ) > qnorm(1-alpha) )
zzz[i] <- ohT/ ( sqrt(2*myValP1) * sum(y^2)/n )
### GT statistics
Y <- y
S <- sum(Y * (XX %*% Y)) / sum((t(tildeUa) %*% Y)^2)
lams <- lam
lams[1:(n-q)] <- lams[1:(n-q)] - S
p.value <- .getP(lams)
gtResult[i] <- (p.value <alpha)
# proposed statistic
theNumerator <- as.numeric(
t(y) %*% myBase %*% y
)
theDenominator <- sum(
(t(tildeUa) %*% y)^2
)
proposedStat <- theNumerator / theDenominator
# estimation of tau square
tildeEpsilon <- tildePa %*% y
tauSquare <-
(
(n-q)^2 * sum(tildeEpsilon^4)/sum(tildeEpsilon^2)^2-
3*sum(diag(tildePa)^2)
)/
(
sum(tildePa^4)
)+
2
if(tauSquare < 0) tauSquare <- 0
tau <- sqrt(tauSquare)
# reference distribution
myRef <- tau * ref1 + ref2
if(mean(myRef > ((n-q)*proposedStat)-sum(diag(myBase))) <alpha){
myResultOld[i] <- 1
}
else{
myResultOld[i] <- 0
}
# myRefStep1 <- tau * (refBase1 - x0 * refPlus1) + refBase2 - x0 * refPlus2
# x1 <- quantile(myRefStep1,1-alpha)/(n-q) + x0
#
# myRefStep2 <- tau * (refBase1 - x1 * refPlus1) + refBase2 - x1 * refPlus2
# x2 <- quantile(myRefStep2,1-alpha)/(n-q) + x0
# if(proposedStat > x2){
#     myResult[i] <- 1
# }
# else{
#     myResult[i] <- 0
# }
#
#
# if(proposedStat > x1){
#     myResultTmp[i] <- 1
# }
# else{
#     myResultTmp[i] <- 0
# }
}
SNR <- 0
for(i in 1:RepTime){
# betaGen
if(betabGen == "dense") {
betabO <- runif(p,-1,1)
}
if(betabGen == "sparse") {
betabO <- runif(p,-1,1)
betabO[sample(p,p/20*19)] <- 0
}
meanSig <- Xb%*% betabO
# Generate y
tmpSNR <- sqrt((n-q)*varGamma)*sum(betabO^2)/p
#betab <- betabO/sqrt(tmpSNR)*sqrt(SNR)
if(epsilonDis == "t")
innov <- rt(n,8)
if(epsilonDis == "chi")
innov <- (rchisq(n,4)-4)/sqrt(8)
y <- innov + meanSig/sqrt(tmpSNR)*sqrt(SNR)
# EigenPrism: inference for high dimensional signal-to-noise ratios
myZ <- as.numeric( t(myUb) %*% y )
ohT <- sum(myEPWeight * myZ^2 )
epResult[i] <- ( ohT/ ( sqrt(2*myValP1) * sum(y^2)/n ) > qnorm(1-alpha) )
zzz[i] <- ohT/ ( sqrt(2*myValP1) * sum(y^2)/n )
### GT statistics
Y <- y
S <- sum(Y * (XX %*% Y)) / sum((t(tildeUa) %*% Y)^2)
lams <- lam
lams[1:(n-q)] <- lams[1:(n-q)] - S
p.value <- .getP(lams)
gtResult[i] <- (p.value <alpha)
# proposed statistic
theNumerator <- as.numeric(
t(y) %*% myBase %*% y
)
theDenominator <- sum(
(t(tildeUa) %*% y)^2
)
proposedStat <- theNumerator / theDenominator
# estimation of tau square
tildeEpsilon <- tildePa %*% y
tauSquare <-
(
(n-q)^2 * sum(tildeEpsilon^4)/sum(tildeEpsilon^2)^2-
3*sum(diag(tildePa)^2)
)/
(
sum(tildePa^4)
)+
2
if(tauSquare < 0) tauSquare <- 0
tau <- sqrt(tauSquare)
# reference distribution
myRef <- tau * ref1 + ref2
if(mean(myRef > ((n-q)*proposedStat)-sum(diag(myBase))) <alpha){
myResultOld[i] <- 1
}
else{
myResultOld[i] <- 0
}
# myRefStep1 <- tau * (refBase1 - x0 * refPlus1) + refBase2 - x0 * refPlus2
# x1 <- quantile(myRefStep1,1-alpha)/(n-q) + x0
#
# myRefStep2 <- tau * (refBase1 - x1 * refPlus1) + refBase2 - x1 * refPlus2
# x2 <- quantile(myRefStep2,1-alpha)/(n-q) + x0
# if(proposedStat > x2){
#     myResult[i] <- 1
# }
# else{
#     myResult[i] <- 0
# }
#
#
# if(proposedStat > x1){
#     myResultTmp[i] <- 1
# }
# else{
#     myResultTmp[i] <- 0
# }
}
mean(zzz)
var(zzz)
zzz
max(sum(myEPWeight^2),sum(myEPWeight^2 * eigenXbXbT^2))
ohMyTmp$value
sum(myEPWeight^2)
sum(myEPWeight^2 * eigenXbXbT^2)
solve
psolve
sum(myEPWeight)
sum(myEPWeight * eigenXbXbT)
?solve
obj <- max(sum(myVariable^2),sum((myVariable^2) * eigenXbXbT^2))
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj),myConstr)
ohMyTmp <- solve(myProblem)
myEPWeight <- ohMyTmp$getValue(myVariable)
# sometimes it returns "optimal_inaccurate"
#myValP1 <- ohMyTmp$value
myValP1 <- max(sum(myEPWeight^2),sum(myEPWeight^2 * eigenXbXbT^2))
myVarP1
myValP1
?entry_sum
?entry_max
?max
ohoh <- eigen(Xb%*%t(Xb),symmetric = TRUE)
eigenXbXbT <- ohoh$values
myUb <- ohoh$vectors
myVariable <- Variable(n)
obj <- max(c(sum(myVariable^2),sum((myVariable^2) * eigenXbXbT^2)))
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj),myConstr)
ohMyTmp <- solve(myProblem)
myEPWeight <- ohMyTmp$getValue(myVariable)
# sometimes it returns "optimal_inaccurate"
#myValP1 <- ohMyTmp$value
myValP1 <- max(sum(myEPWeight^2),sum(myEPWeight^2 * eigenXbXbT^2))
myVarP1
myValP1
max(c(1,2))
ohoh <- eigen(Xb%*%t(Xb),symmetric = TRUE)
eigenXbXbT <- ohoh$values
myUb <- ohoh$vectors
myVariable <- Variable(n)
obj <- max(c(sum((myVariable^2) * eigenXbXbT^2), sum(myVariable^2)))
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj),myConstr)
ohMyTmp <- solve(myProblem)
myEPWeight <- ohMyTmp$getValue(myVariable)
# sometimes it returns "optimal_inaccurate"
#myValP1 <- ohMyTmp$value
myValP1 <- max(sum(myEPWeight^2),sum(myEPWeight^2 * eigenXbXbT^2))
myValP1
sum(myEPWeight^2)
sum(myEPWeight^2 * eigenXbXbT^2)
obj <- max(sum((myVariable^2) * eigenXbXbT^2), sum(myVariable^2))
obj <- max(sum((myVariable^2) * eigenXbXbT^2))#, sum(myVariable^2))
myConstr <- list(sum(myVariable)==0, sum(eigenXbXbT * myVariable)==1)
myProblem <- Problem(Minimize(obj),myConstr)
ohMyTmp <- solve(myProblem)
sum(myEPWeight^2)
sum(myEPWeight^2 * eigenXbXbT^2)
ohMyTmp$value
obj <- max(sum((myVariable^2) * eigenXbXbT^2)), sum(myVariable^2))
myEPWeight
eigenXbXbT^(-1)-mean(eigenXbXbT^(-1))
myValP1
lambda
eigenXbXbT
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
myValP1
ohMyTmp$value
sum(myEPWeight^2 * eigenXbXbT^2)
sum(myEPWeight^2)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
?standardize
?scale
scamle(X)
scale(X)
colMeans(X)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
Xb <- sqrt(0.9)*rnorm(n*p)
dim(Xb) <- c(n,p)
for(i in 1:n){
Xb[i,] <- Xb[i,] + sqrt(0.1)*rnorm(1)
}
svd(Xb)
svd(Xb)$d
p
svd(Xb)$d^2
mean(svd(Xb)$d^2)
tmp <- matrix(rep(0,p*p),p)
for(i in 1:p) for (j in 1:p)
tmp[i,j] <- 0.9^(abs(i-j))
Xb <- mvrnorm(n,rep(0,p),tmp)
svd(Xb)$d
Xb <- rnorm(n*p)
dim(Xb) <- c(n,p)
svd(Xb)$d
source('~/regressionPaper/BayesFactor/formal/code/main.R', echo=TRUE)
